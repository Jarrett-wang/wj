服务器的概念：
    是网络为客户端计算机提供各种服务的高性能计算机
    服务器就是个软件 这个软件主要是可以为客户端提供服务的软件  ---- 如果参与运算程序需要配合后台语言java   php   c；
    只有当其他计算机中的浏览器发出请求时 服务器才能响应
B/S架构：  浏览器与服务器交互；
C/S架构：  下载到本地 在与服务器交互；

ip：
    每台计算机的标识 ---作为一个计算机的标识

url: 地址栏中输入的网址url  统一资源定位符    http:www.baidu.com/index.html?id=1  
    http:https  超文本传输协议  服务器传输超文本到本地浏览器的传送协议；
    注意： http是无链接 含义是每次链接只处理一个请求 收到客户的应答即断开；
          http请求时无状态请求  是指对事物没有记忆能力  CGI处理程序
    www：万维网服务器 是指世界各地的计算机网络
   baidu.com： 是百度的域名
   index.html：文件路径

   域名与ip地址对应关系： 
        多个域名可以对应一个ip地址


php的特点：
    混合了c  java  php自创的语法
    php可以将程序嵌入到网页中去
    支持所有流行的数据库以及操作系统
    弱类型

php的输出语句：
    echo  只能输出字符串 等单一数据 不能输出数据类型 数组等
    print(): 只能输出字符串 等单一数据  不能输出数据类型 数组等有返回值
    print_r(): 可以输出字符串 数组。。可以输出复杂数据类型
    var_dump: 字符串 数据类型  长度
    die()  先输出内容 退出程序
php中的函数：
    isset():判断变量是否定义；
        如果定义返回true   否则返回false
        在php中true---->1   false---null
    empty():
        判断值是否为空； 0   "0"  false    Array()   null
    unset(): 删除变量

php第二天：
php中的数组：
    索引数组：通过索引操作数组
        $arr = Array(1,2,3,true,"abc");
        $arr = [1,2,3,4,5]
       
        访问与js一样；
    隐形数组：$arr[] = 1;给变量增加一个中括号 系统自动生成数字下标 与值
            对于索引数组： 自动递增数组的索引
            对于关联数组： 从0开始索引
    二维数组：
        $arr = Array(
            "first"=>Array(
                "name"=>"jack",
                "age"=>20
            ),
            "two"=>Array(
                "name"=>"jack",
                "age"=>20
            )
        );
     关联数组：
        以键值对的形式描述数据
            $arr = array(
                "name"=>"jack",
                "age"=>20,
                "gender"=>true
            )  
    
    for($i = 0;$i<count($arr);$i++){
        只能遍历索引数组
    }
       
    遍历数组：
        foreach($arr as $key=>$value){
           遍历索引数组  与关联数组
           $key：属性（索引）
           $value 值
        } 
        foreach($arr as $value){
      
    }
    数组的注意事项：
        1.如果添加元素的时候设置key name就没有索引
        2.如果没有设置key值 那么系统自动生成索引
        3.如果数组已经存在 那么就将元素添加到当前数组中
        4.如果不存在就先创建 在赋值
    二维数组遍历：
        foreach($arr as $value){
            // print_r($value);
            foreach($value as $value1){
                print_r($value1);
            }
        }
    
    数据类型转换：
        转换整型：$num = (int)$str; 
        转换为浮点型：$int = floatval($num);
        转化为字符串：(String)$str
        转化布尔型： (bool)$str
        算数运算符：
            + - * % ++ --；
        逻辑运算符：
            ! && ||；
        比较运算符：
             >  <  >= <= ==
        三元运算符：
            a>b?"":""
 global:引用全局变量 
    1.  不能再引用的同时对变量赋值 
        2.  如果没有参数项引用其他变量  需要global；
            3.  global 本质是引用 改变值全局也会发生变化；

php字符串拼接：
    字符串与字符串之间用  点(.)
    单引号与双引号的区别： 
        双引号会解析变量
超全局变量：       
    $GLOABLS;
    $_SERVER;
    $_GET
    $_POST
    $_COOKIE
    $_SESSION
只要定义变量 都会存储在超全局变量中的  $GLOABLS;

$GLOABLS 与  global区别：
    $GLOABLS 真实存在的
    global  只是引用

定义常量的语法：
    define("常量名称",常量值,true|false)；
    例如： define("PI",3.14,true);  true:不敏感（支持大写和小写）;
魔术常量：
    __LINE__ 当前的代码行数
    __FILE__:当前文件夹的路径
    __DIR__:获取文件目录;

载入文件： 相当在当前文件下执行代码；
    include:  1.如果引入失败  不会影响下面的元素 可以执行多次;
    include_once:  2.当引入失败不会影响下面 的元素的执行！多次的情况下  只会载入一次。
    require: 如果代码载入失败，后续代码不会执行
    require_once:2.当引入文件失败会影响下面的代码的执行  只能引入一次；
    
strlen() 获取字符串的长度
时间：
    echo date("Y-M-D H:I:S");
读取文件：
    file_get_contents:读取文件
写入文件：
    $res = file_put_contents("data.txt","写入的内容",");

php第三天： 
    get与post：
        1.get方式：
            (1).在地址栏中显示
            (2).数据到 大小 4-5kb   1kb = 1024b    //1b = 1字符  一个中文=2b
            (3).不安全
            (4).速度快  
            (5).获取数据
        2.哪些是get的方式：
            src 
            href
            表单提交（默认）   
        3.显示方式：
            username=kf&password=123
            key值=name中的属性值（默认）
        post:
            (1).相对于get方式比较安全
            (2).不会再地址栏中显示
            (3).通常为了存储数据
            (4).速度慢
        手动设置提交方式
        
单选按钮的提交
    需要给单选按钮设置value值 
多选按钮的提交：
    需要给name属性值加[]  同时设置value值
下拉列表的提交：
    如果设置value值 那么提交是value的值  如果没有设置value 提交的是option的文本内容

    常见的get请求方式 
        地址栏访问
        src
        href
    get请求方式的格式：
        index.php?username=jack&password=123;
        参数名与参数值没有空格
        参数值不需要引号
    get方式提交数据的特点：
        在url拼接参数
        只能以文本的形式传递
        传输大小4kb
        安全性低
        速度快    
    post方式安全性比较高
    传输量大  对数据的长度没有要求
    请求不会被缓存 不会保留历史记录里面 
    大小8mb 
$_SERVER["REQUEST_METHOD"] =="POST"|"GET";
$_SERVER["PHP_SELE"]:可以获取当前文件的路径
form:
单选按钮：
    1.系统自动获取当前表单的value值
    2.我们也可能为单选按钮设置 value属性 只不过默认on 
    3.我们需要设置value属性
    button也会做一个默认提交功能；     return false
    form    
复选按钮：
    如果多个复选框里面的值一样 就会默认传递最后一个值
    在name后面添加中括号
下拉列表：
    如果没有设置value属性值 就会默认传递当前被选择的option
    如果设置了value 就会传递value
上传文件：
    存储在$_FILE[];
php第四天：
    json文件;
        [
            {
                "title":"张三",
                "singer":"张三的歌",
            },
            {
                "title":"各三个",
                "singer":"张三的歌",
            }
        ]
    与对象的区别：
        json文件属性与属性值必须加引号（双引号）;
    
    音乐列表：
    1.list.php  
            1.先读取文件
            2.转化数组
            3.遍历数组渲染页面;
    2.upload.php
        判断：
         1.   if(!isset($_POST["title"])||trim($_POST["title"])==""){
                $error[] = "title";
            }	
            if(!isset($_POST["singer"])||trim($_POST["singer"])==""){
                $error[] = "singer";
            }
            if(!isset($_POST["album"])||trim($_POST["album"])==""){
                $error[] = "album";
            }
            // 判断文件
            if(!isset($_FILES)||$_FILES["source"]["error"]!=0){
                $error[] = "source";
            }
            if(isset($error)){
                $GLOBALS["error"] = $error;
                return;
            }
        2.上传文件 move_uploaded_file($_FILES["source"]["tmp_name"],"./mp3/".$_FILES["source"]["name"]);
        3.读取文件 
            $data = file_get_contents("..json");
        4.转化数组
            $dataArr = json_decode($data,true);
        5.创建数组数组；
            $new = array(
    			"id"=>$dataArr[count($dataArr)-1]["id"]+1,
    			"title"=>$_POST["title"],
    			"singer"=>$_POST["singer"],
    			"album"=>$_POST["album"],
    			"src"=>"./mp3/".$_FILES["source"]["name"]
    		);
        5.追加数组：
            $dataArr[] = $new;
        6.写入数组：
            file_put_contents("music.json",json_encode($dataArr))
    3.del.php 
        1.读取数据  
        2.转化数组
        3.遍历数组中的id是否与穿过来的id一致
        $id = $_GET["id"];
        // 1.取出数据  转化数组
        $data = file_get_contents("music.json");
        $dataArr = json_decode($data,true);
        // 2.判断与传过来的id 是否一致
        foreach($dataArr as $key=>$value){
            if($value["id"]==$id){
                array_splice($dataArr,$key,1);
                file_put_contents("music.json",json_encode($dataArr));
                echo "<script>location.href='list.php';</script>";
            }
        }
    4.
        edit.php
            1.读取数组 
            2.转化数组
            3.判断与传过来的id 是否一致 
            4.如果一致 做对应的修改
            5.在写入文件

php第四天： 
    http状态：
        三次握手：  
            1.浏览器向服务器发送编码（syn seo ack） 发送请求链接；
            2.服务器接受syn码 在发送给客户端syn+ack码 我可以建立链接
            3.浏览器接受成功之后告诉服务器 通道开启；
        
        四次挥手：
            当客户端无数据传输FIN码告诉服务器我发送完毕 请求关闭通道;
            当服务器接受完毕告诉(ack码)客户端 可以把数据通道关闭;
            当服务器发送完毕之后也会发送fin码告诉浏览器 数据发送完毕
            当客户端接受完毕之后告诉服务器 数据接受完毕 你可以关闭


        请求：
            请求行   请求头  请求体（只要post）
              请求行：  状态 空格 url地址 http协议
            建立通道之后：  
                1.先发送与自身相关的信息在发送请求头 空行表示请求头发送完毕（如果是post继续发送正文）
                2.响应内容： 发送状态码 
                3.响应内容： 先发送自身的相关信息  发送正文
                4.关闭链接通道关闭
        一个回话过程！！！
    http的特点：
        无状态： 服务器不会保留客户端任何的信息；
    cookies：
        原理：
            1.客户端向服务器发送请求
            2.cookies在服务器端生成    islogin = true;
            3.默认把cookies值发送到客户端；  jack
            4.客户端再去浏览其他页面都会携带cookies值（当前的文件夹）
        默认的声明周期： 关闭页面数据消失！！
    
        创建cookie值
            setcookie(名字，值，时间，路径（访问路径权限），访问域名)
            setcookie("name","kf",PhP_INT_MAX);
            设置权限为父级目录子集也可以访问
        获取：  
            $_COOKIE[名字];
        删除
            setcookie("name","",PhP_INT_MAX);
       cookies缺点：
            存储的大小受限制
            只能存储字符串。
            不安全；
    session:    
        原理：  
            1.客户端向服务器发送请求
            2.session在服务器端生成    
                	// $_SESSION["user"] = array(
                        // 	"username" => $_POST["username"],
                        // 	"userPwd" => $_POST["password"],
                        // 	"isLogin" => "yes"
                    //   );
            3.默认把session的id 发送客户端 （会把user 加密生成----id号）
            4.发送前台（客户端）-------以cookie的形式返回；set-cookies
            4.客户端再去浏览其他页面都会携带session值（当前的文件夹）；
        创建：
            $_SESSION["名字"] = 值（字符串  值  布尔 对象 数组）
        删除：
            unset($_SESSION["user"]);
        获取：
          echo  $_SESSION["名字"];



    sql语句：
        1.查询：
            1.简单查询：
                select * from 表名
            2.带条件查询  
                select * from 表名 where age>30(条件)
            3.子查询： 当前的select 在另一个select里面去执行
                SELECT *FROM 
-- 					person 
-- 	            WHERE 
-- 					age >
-- 					(SELECT age FROM person where name="李四");
            4.判断条件  >  < >=  <= ==  !=  and  or  not
            5.like 模糊查询：
                select * FROM person where name LIKE "%三%"
            6.in 查询某个字段的值是否属于in列表中的某一项
                语法：SELECT * from person WHERE id in(1,3,4);
            7.between  and  在---之间：
                语法：SELECT *FROM person where age BETWEEN 50 and 80;
        2.增加  
            inser into 表名 values(添加的内容)：
            语法： 
                INSERT INTO person VALUES(null,"hanmeimei","男","18","篮球","180");
            添加某一个值：
                INSERT INTO person（name） VALUES("张三");
        3.修改：
            update 表名 set name = “。。”；
                 UPDATE person set name = "王五" WHERE id = 1;
        4.删除：    
            delete 表名 where
            语法：DELETE from person WHERE id = 9;
        5.数学函数：
            平均值：  SELECT avg(age) count FROM person;
            最大值： SELECT max(age) count FROM person;
            最小值： SELECT min(age) count FROM person;
            总个数： SELECT count(age) count FROM person;
        6.字符串函数：
            拼接： concat拼接
                语法：SELECT CONCAT(name,"-",age) NAME FROM person;
            sql语句  索引从1开始
                语法：SELECT substr(name,截取的索引,截取的长度) FROM person;
             instr返回对应的索引  如果没有找到返回0
                语法：SELECT instr(name,"三") FROM person  WHERE id = 1;
        7. order by  desc(降序)  asc（升序）
                语法：SELECT * from person order by id desc
        8. SELECT * from person  limit 2;    
        9.多表查询
        语法1：SELECT * FROM posts,users WHERE posts.user_id=users.id;
        语法2： SELECT * FROM posts LEFT JOIN users ON posts.user_id=users.id;
    php语法：
        总结：
            1.链接数据库 
                $con = mysqli_connect("localhost","root","root","mybase");
            2.创建sql语句 
                $sql = "SELECT * FROM person";
            3.执行sql语句：
                mysqli_query($con,$sql);
            4.遍历结果：  while($arr = mysqli_fetch_assoc($res)){
                    $result[] = $arr;
                }







    ajax:第一天：
        ajax：什么是网页的交互技术：
            创建交互式网页的开发技术，ajax实现网页的   异步更新  在不加载整个页面的情况下
            对页面的某个部分进行更新。
    
       好处： 增强了用户体验;
        ajax请求步骤：
        get方式：
            1.创建异步对象 
                 var xhr = new XMLHttpRequest();
            2.设置请求行：
                无参： xhr.open("get", "a.php");
                有参： xhr.open("get", "abc.php?uname=" + uname.value);
            3.设置请求体：
                xhr.send(null);  get请求没有请求体；
            4.监听异步状态：
                 xhr.onreadystatechange = function () {
                5.判断服务器返回的状态码  xhr.status  200
                     400：—错误请求，如语法错误
                     404：没有发现文件、查询或URl
                     505——服务器不支持或拒绝支请求头中指定的HTTP版本
                6.xhr.readyState   4
                    readyState=0: 已经创建了异步对象 还没有调用open
                    readyState=1：已经调用了open方法 服务器建立链接 初始化完成
                    readyState=2: send方法执行完毕  请求发送 接受到了信息
                    readyState=3：浏览器接受到了响应数据
                    readyState=4 请求完成 响应完成 数据解析完毕
                     if (xhr.status == 200 && xhr.readyState == 4) {
                         xhr.responseText :后台返回的内容；
    
                     }
                 }
    post方式：
          1.创建异步对象 
                 var xhr = new XMLHttpRequest();
            2.设置请求行：
              xhr.open("get", "a.php");
            3.设置请求头：
                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); 
            4.请求体：
                xhr.send(参数)
            5.判断服务器返回的状态码  xhr.status  200
                     400：—错误请求，如语法错误
                     404：没有发现文件、查询或URl
                     505——服务器不支持或拒绝支请求头中指定的HTTP版本
            6.xhr.readyState   4
                    readyState=0: 已经创建了异步对象 还没有调用open
                    readyState=1：已经调用了open方法 服务器建立链接 初始化完成
                    readyState=2: send方法执行完毕  请求发送 接受到了信息
                    readyState=3：浏览器接受到了响应数据
                    readyState=4 请求完成 响应完成 数据解析完毕
                     if (xhr.status == 200 && xhr.readyState == 4) {
                         xhr.responseText :后台返回的内容；
    
                     }
                 }；
                 
        get与post区别
            1.get请求没有请求体  post有请求体
            2.post需要设置请求头 get不需要设置；
            3.get大小4kb  post 无限制
            4.post相对安全   get不安全  md5
            
            状态码：
    
                100——客户必须继续发出请求
                101——客户要求服务器根据请求转换HTTP协议版本
                200——交易成功
                201——提示知道新文件的URL
                202——接受和处理、但处理未完成
                203——返回信息不确定或不完整
                204——请求收到，但返回信息为空
                205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
                206——服务器已经完成了部分用户的GET请求
                300——请求的资源可在多处得到
                301——删除请求数据
                302——在其他地址发现了请求数据
                303——建议客户访问其他URL或访问方式
                304——客户端已经执行了GET，但文件未变化
                305——请求的资源必须从服务器指定的地址得到
                306——前一版本HTTP中使用的代码，现行版本中不再使用
                307——申明请求的资源临时性删除
                400——错误请求，如语法错误
                401——请求授权失败
                402——保留有效ChargeTo头响应
                403——请求不允许
                404——没有发现文件、查询或URl
                405——用户在Request-Line字段定义的方法不允许
                406——根据用户发送的Accept拖，请求资源不可访问
                407——类似401，用户必须首先在代理服务器上得到授权
                408——客户端没有在用户指定的饿时间内完成请求
                409——对当前资源状态，请求不能完成
                410——服务器上不再有此资源且无进一步的参考地址
                411——服务器拒绝用户定义的Content-Length属性请求
                412——一个或多个请求头字段在当前请求中错误
                413——请求的资源大于服务器允许的大小
                414——请求的资源URL长于服务器允许的长度
                415——请求资源不支持请求项目格式
                416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
                417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求
                500——服务器产生内部错误
                501——服务器不支持请求的函数
                502——服务器暂时不可用，有时是为了防止发生系统过载
                503——服务器过载或暂停维修
                504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
                505——服务器不支持或拒绝支请求头中指定的HTTP版本
    
        json数据：
            一种描述数据的数据(格式)
            {
                "name":"kf"
            };












            xml数据格式：
                元数据： 描述数据的数据
                数据的弊端：
                    元数据 占用的数据量比较大  不利于大量数据的网页渲染
                    解析不方便
        ajax第二天：
            jq里面的参数：
                url接口地址
                type请求方式
                timeout：请求超时
                dataType：服务器返回的格式
                beforeSend：function(){} 请求发起前调用
                success： 成功的会调用
                error：失败调用
                complete： 响应完成时调用;
        $.ajax({
            type:"",
            url:"",
            data:{},
            dataType:"jsonp",
            success:function(res){
                console.log(res)
            },
            error:function(res){
    
            }
        })




        ajax第三天：
            同源策略是一种约定 它是浏览器最核心 最基本的安全功能 缺少同源策略 浏览器很容易受到 攻击4
             就是域名与域名之间不能随意  设置  获取东西
             限制： 限制的内容 Cookie  localstorage   dom节点  ajax
           
            xss跨站脚本攻击
            同源策略： 协议+ 域名+端口三者相同 
              三个标签允许跨域：
                img
                link
                src
            跨域： 跨域并不是请求没有发出去  请求能够发出去  服务器正常返回内容 结果被浏览器拦截了;
       解决：
        1.在响应头设置：header("Access-Control-Allow-Origin:*");允许所有的网站读取信息；
            利用标签没有限制的漏洞 网页可以动态获取数据jsonp格式需要对方服务器支持才可以
    
        <script>
            function fn(res){
                consoole.log(res)
            }
        </script>




      原理：    jsonp
            1.声明一个函数 其函数名当参数值 要传递给跨域请求数据的服务器函数的形参返回的数据
            2.创建一个script标签 把那个跨域的API数据的接口地址 赋值给script 的src  属性值是函数名
            3.服务器接受到请求后，需要进行特殊的处理 把传递过来的函数名 和需要给他的数据拼接一个字符串
            4.最后服务器把准备的数据通过http协议返回给客户端，客户端在调用执行。
    jq：jsonp都是get和异步请求不存在其他的请求方式 默认给jsonp请求清除缓存； 

var $ = {
    getstr: function (data) {
        if (data && typeof data == "object") {
            var str = "?";
            for (var k in data) {
                str = str + k + "=" + data[k] + "&";
            }
            str = str.substr(0, str.length);
        }
        return str;
    },
    ajax: function (option) {
        var type = option.type || "get";
        // 地址
        var url = option.url || location.href;
        // 参数
        var data = this.getstr(option.data) || "";
        var success = option.success;
        var xhr = new XMLHttpRequest();
        if (type == "get") {
            url + data;
            data = null;
        }
        xhr.open(type, url);
        if (type == "post") {
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        }
        xhr.send(data)
        xhr.onreadystatechange = function () {
            if (xhr.status == 200 && xhr.readyState == 4) {
                var rh = xhr.getResponseHeader("Content-Type");
                if (rh.indexOf("xml") != -1) {
                    var result = xhr.responseXML;
                } else if (rh.indexOf("json") != -1) {
                    var result = JSON.parse(xhr.responseText);
                } else {
                    var result = xhr.responseText;
                }
                success && success(result);
            }
        }
    }
}























​    









































































